# Руководство по OAuth2 в задаче по интеграции Google Calendar в проект

Процесс авторизации и сохранения токенов состоит из нескольких шагов, которые организованы в следующую цепочку взаимодействия:

1. **Инициация процесса авторизации (редирект для авторизации):**
  - Пользователь инициирует процесс авторизации, вызывая метод контроллера `GET /oauth/redirect` (`GoogleOAuthController`).
  - Контроллер вызывает метод `oAuthService.buildAuthorizationUrl()` для создания URL авторизации. В этом URL указываются необходимые параметры, такие как уникальный `state`, `redirectUri` для обратного вызова и параметры, запрашивающие офлайн-доступ (`offline`) - при этом параметре нам отправляют refresh токен.
  - После генерации URL контроллер перенаправляет пользователя на страницу авторизации Google, где он может предоставить разрешения приложению для доступа к своему календарю.

2. **Переход на страницу авторизации и предоставление разрешений:**
  - Пользователь перенаправляется на страницу авторизации Google и предоставляет разрешения приложению.
  - После успешной авторизации пользователь возвращается на указанный `redirectUri` с кодом авторизации или ошибкой, если авторизация не удалась.

3. **Обработка обратного вызова (callback) после авторизации:**
  - Контроллер `OAuthCallbackController` обрабатывает запрос (`GET /oauth/callback`). Он принимает параметры `code` (код авторизации) и `error` (если возникла ошибка).
  - Контроллер вызывает метод `oAuthService.processOAuthCallback()`, передавая ему код авторизации и возможные ошибки.
  - Внутри метода `processOAuthCallback()` проверяется наличие ошибок. Если обнаружена ошибка, выбрасывается исключение `BadRequestException`. Если ошибок нет, метод передает код авторизации на дальнейшую обработку в `handleOAuthCallback()`.

4. **Обмен кода авторизации на токены:**
  - Метод `handleOAuthCallback()` в `OAuthService` выполняет основной процесс обмена кода авторизации на токены (`access_token` и `refresh_token`):
    - Создается запрос на обмен кода (`googleAuthorizationCodeFlow.newTokenRequest(code)`).
    - Устанавливается `redirectUri` для обратного вызова.
    - Выполняется запрос (`execute()`), и в случае успеха возвращаются токены.
    - Полученные токены сохраняются в специальном хранилище данных с помощью метода `createAndStoreCredential()`.
    - Если происходит ошибка при обмене кода на токены, метод выбрасывает исключение `GoogleCalendarException`.

5. **Сохранение токенов в базе данных:**
  - Хранилище данных (`DatabaseCredentialDataStore`) отвечает за управление OAuth2 токенами, используя реализацию интерфейса `DataStore`.
  - В методе `set()` токены передаются для сохранения:
    - Получается последний сохраненный токен из базы данных через `tokenService.getLatestToken()`. Если токена нет, создается новый объект `GoogleAuthToken`.
    - Устанавливаются значения `accessToken`, `refreshToken`, время истечения (`expiresIn`), и время создания (`createdAt`).
    - Вызывается метод `tokenService.saveToken()` для сохранения токена в базе данных.
    - Записывается лог об успешном сохранении токена в базу данных.

6. **Использование сервиса для управления токенами:**
  - Сервис `TokenService` отвечает за непосредственное взаимодействие с репозиторием токенов (`TokenRepository`), который реализует доступ к базе данных, методы этого класса использует `DatabaseCredentialDataStore` для управления токенами.
  - Метод `saveToken()` в `TokenService` выполняет операцию сохранения токена в базе данных. 

7. **Результат:**
  - В результате этого процесса OAuth2 токены, необходимые для доступа к Google Calendar API, успешно сохраняются в базе данных. Это позволяет приложению получать и обновлять токены автоматически, что особенно важно для офлайн-доступа (`offline`), когда обновление токенов может происходить без вмешательства пользователя.
